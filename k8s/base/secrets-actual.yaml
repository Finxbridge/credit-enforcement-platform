# ============================================
# KUBERNETES SECRETS TEMPLATE
# ============================================
#
# WHY SECRETS?
# - Docker Compose uses .env files (plain text, committed to git - INSECURE!)
# - Kubernetes Secrets store sensitive data encrypted at rest
# - Can be injected as environment variables or mounted as files
# - Can integrate with external secret managers (AWS Secrets Manager, HashiCorp Vault)
#
# IMPORTANT: This is a TEMPLATE file
# DO NOT commit actual secrets to git!
#
# DEPLOYMENT STEPS:
# 1. Copy this file: cp secrets.yaml secrets-actual.yaml
# 2. Replace <BASE64_ENCODED_VALUE> with actual base64 values
# 3. Add secrets-actual.yaml to .gitignore
# 4. Apply: kubectl apply -f secrets-actual.yaml
#
# To encode a value to base64:
#   echo -n "your-secret-value" | base64
#
# ============================================

---
apiVersion: v1
kind: Secret
metadata:
  name: postgres-credentials
  namespace: credit-enforcement-v2
type: Opaque
data:
  # Your OVH PostgreSQL credentials
  # Current values from .env (EXAMPLE - DO NOT USE IN PRODUCTION):
  # host: postgresql-9011f0fc-o4187f84d.database.cloud.ovh.net
  # port: 20184
  # database: defaultdb
  # username: avnadmin
  # password: KE5PMicV9Z0aO1XJRNx3
  #
  # Base64 encode each value separately:
  postgres-host: cG9zdGdyZXNxbC05MDExZjBmYy1vNDE4N2Y4NGQuZGF0YWJhc2UuY2xvdWQub3ZoLm5ldA==
  postgres-port: MjAxODQ=
  postgres-database: ZGVmYXVsdGRi
  postgres-username: YXZuYWRtaW4=
  postgres-password: S0U1UE1pY1Y5WjBhTzFYSlJOeDM=

---
apiVersion: v1
kind: Secret
metadata:
  name: jwt-secret
  namespace: credit-enforcement-v2
type: Opaque
data:
  # JWT secret for token signing
  # Must be at least 256 bits for HS256 algorithm
  # Example command to generate secure secret:
  #   openssl rand -base64 32 | base64
  jwt-secret: R01QL3JpVFJCdUZtbmJ2RXEzNWVIcVZtZXNucFl5T1p0MncxVFV4U0xodz0=
  jwt-issuer: ZmlueGJyaWRnZQ==  # Example: finxbridge

---
apiVersion: v1
kind: Secret
metadata:
  name: redis-credentials
  namespace: credit-enforcement-v2
type: Opaque
data:
  # External Redis credentials (OVH managed Redis)
  # Replace these with your actual Redis credentials encoded in base64:
  #   echo -n "your-value" | base64
  redis-host: dmFsa2V5LWFkOGRiMTU1LW80MTg3Zjg0ZC5kYXRhYmFzZS5jbG91ZC5vdmgubmV0
  redis-port: MjAxODU=  # 6379 in base64
  redis-username: ZGVmYXVsdA==
  redis-password: YmZrSHRSNEI4U0xwNnNqMXUzQUc=
  redis-ssl-enabled: dHJ1ZQ==  # "true" in base64 - OVH Redis typically uses SSL

---
# apiVersion: v1
# kind: Secret
# metadata:
#   name: ovh-registry-secret
#   namespace: credit-enforcement
# type: kubernetes.io/dockerconfigjson
# data:
#   # This secret allows Kubernetes to pull images from your private OVH registry
#   # Generate this with:
#   #   kubectl create secret docker-registry ovh-registry-secret \
#   #     --docker-server=qvwy18uw.c1.de1.container-registry.ovh.net \
#   #     --docker-username=<YOUR_OVH_USERNAME> \
#   #     --docker-password=<YOUR_OVH_PASSWORD> \
#   #     --namespace=credit-enforcement \
#   #     --dry-run=client -o yaml | grep '\.dockerconfigjson:' | awk '{print $2}'
#   #
#   .dockerconfigjson: <BASE64_ENCODED_DOCKER_CONFIG_JSON>

---
# CORS and other application configs can be in ConfigMap (non-sensitive)
# or here if you want to keep them private
apiVersion: v1
kind: Secret
metadata:
  name: app-config-secrets
  namespace: credit-enforcement-v2
type: Opaque
data:
  # CORS allowed origins (if sensitive)
  cors-allowed-origins: aHR0cDovL2xvY2FsaG9zdDozMDAw
